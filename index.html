<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>トップ | プログラミング学習</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <script src="config.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    .container { max-width: 720px; margin: 40px auto; padding: 24px; border: 1px solid #e5e5e5; border-radius: 12px; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .meta { color: #555; margin-bottom: 16px; }
    .actions { margin-top: 20px; display: flex; gap: 12px; }
    button { padding: 10px 16px; border-radius: 8px; border: 1px solid #ccc; background: #1677ff; color: #fff; cursor: pointer; }
    button.secondary { background: #fff; color: #1677ff; border-color: #1677ff; }
    .msg { margin-top: 12px; color: #888; }
    .task-state-summary { margin-top: 16px; padding: 12px; border: 1px solid #e5e5e5; border-radius: 10px; background: #fafafa; }
    .task-state-summary .state-group { margin-top: 8px; }
    .task-state-summary .state-header { display: flex; align-items: center; gap: 8px; cursor: pointer; }
    .task-state-summary .state-toggle { width: 26px; height: 26px; padding: 0; border-radius: 6px; border: 1px solid #ccc; background: #fff; color: #555; font-size: 14px; line-height: 1; }
    .task-state-summary .state-toggle:focus { outline: 2px solid #91caff; outline-offset: 1px; }
    .task-state-summary .state-header .state-icon { margin-right: 4px; }
    .task-state-summary .state-list .state-item { display: flex; align-items: center; gap: 8px; justify-content: space-between; }
    .task-state-summary .state-list .state-item .state-title-text { flex: 1 1 auto; }
    .task-state-summary .state-list .state-start-btn { padding: 4px 8px; font-size: 0.9em; border-radius: 6px; border: 1px solid #1677ff; background: #f0f7ff; color: #1677ff; cursor: pointer; }
    .task-state-summary .state-list .state-start-btn:hover { background: #e6f0ff; }
    .task-state-summary .state-title { font-weight: 600; }
    .task-state-summary .state-count { color: #666; font-size: 0.9em; }
    .task-state-summary .state-list { margin: 6px 0 0 34px; padding: 0; }
    .task-state-summary .state-list li { list-style: none; padding: 2px 0; color: #333; font-size: 0.95em; word-break: break-all; }
    .task-state-summary .state-empty { color: #777; font-size: 0.9em; margin-left: 0; }
    .task-state-summary .state-caption { font-weight: 700; color: #444; margin-bottom: 4px; }
  </style>
  <style>
    /* 事前プリロード中の簡易インジケータ */
    #preloadStatus { font-size: 0.9em; color: #555; margin: 8px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>プログラミング学習</h1>
    <div id="meta" class="meta"></div>
    <div class="actions">
      <button id="primaryBtn">読み込み中...</button>
    </div>
    <div id="taskStateSummary" class="task-state-summary" hidden></div>
    <div id="note" class="msg"></div>
  </div>

  <script>
    (function(){
      const meta = document.getElementById('meta');
      const btn = document.getElementById('primaryBtn');
      const note = document.getElementById('note');

      const APP = window.APP_CONFIG || {};
      const server = APP.serverBaseUrl || '';

      function qs(key){ return new URLSearchParams(location.search).get(key); }
      function setSession(sid, uid, cls, num){
        try {
          localStorage.setItem('sessionId', sid);
          localStorage.setItem('userId', uid || '');
          localStorage.setItem('classId', cls || '');
          localStorage.setItem('number', num || '');
          sessionStorage.setItem('sessionId', sid);
          sessionStorage.setItem('userId', uid || '');
          sessionStorage.setItem('classId', cls || '');
          sessionStorage.setItem('number', num || '');
        } catch {}
      }

      const toForm = (obj) => Object.keys(obj).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(obj[k] ?? '')).join('&');

      async function validateSession(sid){
        if (!server || !sid) return null;
        try{
          // 既存デプロイに確実に存在する ping を使用（session付きでvalidate）
          const res = await fetch(server, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: toForm({ action: 'ping', session: sid })
          });
          if (!res.ok) { console.warn('[index] validateSession http', res.status); return null; }
          const data = await res.json();
          if (data && data.status === 'ok'){
            // ユーザ情報が帰ってくる場合のみ上書き（無くてもOK）
            if (data.userId || data.classId || data.number) {
              setSession(sid, data.userId, data.classId, data.number);
            }
            return data;
          }
          console.warn('[index] validateSession app err', data);
          // ここで null 返すとUIがセッション破棄動線に落ちるため、nullでは返さない
          return {status:'ok'}; // 最低限OK扱いにしてプリロードを継続
        }catch(e){
          console.warn('[index] validateSession err', e);
          return {status:'ok'}; // ネットワーク断でもセッションを維持
        }
      }

      async function main(){
        btn.disabled = true; btn.textContent = '読み込み中...';
        // 1) sid= がURLにある場合は優先採用
        const sidFromUrl = qs('sid');
        if (sidFromUrl){
          const v = await validateSession(sidFromUrl);
          if (v){
            meta.textContent = `クラス:${v.classId || '?'}　出席番号:${v.number || '?'}（${v.userId || ''}）`;
            btn.textContent = 'プログラミングをはじめる';
            btn.disabled = false;
            btn.onclick = () => location.href = 'main.html';
            note.textContent = 'QRコード等からのアクセスを検出しました。上のボタンから学習画面へ進んでください。';
            // ← セッション確定を通知（プリロードはこのイベントで開始）
            window.dispatchEvent(new Event('session-ready'));
            return;
          } else {
            note.textContent = 'URLのセッションが無効でした。ログインしてください。';
            // fallthrough to local check
          }
        }

        // 2) localStorage の sessionId
        const sidLocal = localStorage.getItem('sessionId');
        if (sidLocal){
          const v = await validateSession(sidLocal);
          // pingは status:ok になればOK扱い。ユーザ詳細は無い場合もある。
          if (v && v.status === 'ok'){
            const uid = v.userId || localStorage.getItem('userId') || '';
            const cls = v.classId || localStorage.getItem('classId') || '?';
            const num = v.number || localStorage.getItem('number') || '?';
            meta.textContent = `クラス:${cls}　出席番号:${num}（${uid}）`;
            btn.textContent = 'プログラミングをはじめる';
            btn.disabled = false;
            btn.onclick = () => location.href = 'main.html';
            note.textContent = 'セッションを検出しました。上のボタンから学習画面へ進んでください。';
            // ← セッション確定を通知（プリロードはこのイベントで開始）
            window.dispatchEvent(new Event('session-ready'));
            return;
          }
          // ここでは sessionId を破棄しない（プリロードとUI継続のため）
        }

        // 3) セッション無し → ログイン導線のみ
        meta.textContent = 'セッションが見つかりませんでした。';
        btn.textContent = 'ログインしてプログラミングをはじめる';
        btn.disabled = false;
        btn.onclick = () => location.href = 'login.html';
        note.textContent = '学校内PCでは初回は登録ページから、2回目以降はログインなしで学習画面に遷移できます。';
      }

      main();
    })();
  </script>
</body>
<script>
// 事前プリロード：セッションがあれば課題一覧＋ユーザー状態をまとめて取得し、localStorageへ保存
(function(){
  const serverBaseUrl = (window.APP_CONFIG && window.APP_CONFIG.serverBaseUrl) || '';
  const buildUrl = (path = '') => {
    if (serverBaseUrl.includes('script.google.com')) return serverBaseUrl;
    return serverBaseUrl + path;
  };
  // デバッグ用にキーを参照できるよう公開
  window.__SNAP_KEY__ = `learn.snapshot.${serverBaseUrl}`;
  // 多重起動ガード
  let __preloadRunning = false;
  const STATE_GROUPS = [
    { key: 'cleared', label: 'クリア済' },
    { key: 'graded', label: '採点済' },
    { key: 'submitted', label: '提出済' },
    { key: 'pending', label: '未提出' }
  ];
  const STATE_COLORS = {
    cleared: '#52c41a',
    graded: '#ff8fb7',
    submitted: '#9254de',
    pending: '#d9d9d9'
  };
  const BASE_KEY = (suffix) => {
    const base = (typeof (window.APP_CONFIG || {}).serverBaseUrl === 'string' && (window.APP_CONFIG || {}).serverBaseUrl) || 'default';
    return `learn.${suffix}.${base}`;
  };
  const SELECTED_KEY = () => BASE_KEY('selectedTask');
  function canonicalHeader(h) { return String(h || '').replace(/^\uFEFF/, '').trim().toLowerCase(); }
  function toBool(v) { const s = String(v || '').trim().toLowerCase(); return s === 'true' || s === '1' || s === 'yes' || s === 'y'; }
  function normalizeAttribute(value) {
    const s = String(value || '').replace(/\s+/g, '').trim();
    const allowed = ['基礎', '演習', '発展', 'その他'];
    if (!s) return 'その他';
    return allowed.includes(s) ? s : 'その他';
  }
  function normalizeSnapshotTasks(raw) {
    if (!Array.isArray(raw) || raw.length === 0) return [];
    if (Array.isArray(raw[0])) {
      const headerRow = raw[0].map(h => canonicalHeader(h));
      const rows = raw.slice(1);
      const idx = {
        taskid: headerRow.indexOf('taskid'),
        title: headerRow.indexOf('title'),
        parentid: headerRow.indexOf('parentid'),
        isfolder: headerRow.indexOf('isfolder'),
        attribute: headerRow.indexOf('attribute')
      };
      const pick = (row, i) => (i >= 0 && i != null) ? row[i] : '';
      return rows.map(r => ({
        id: pick(r, idx.taskid) || '',
        title: pick(r, idx.title) || pick(r, idx.taskid) || '',
        parentId: pick(r, idx.parentid) || '',
        isFolder: toBool(pick(r, idx.isfolder)),
        attribute: normalizeAttribute(pick(r, idx.attribute))
      })).filter(t => t.id);
    }
    if (typeof raw[0] === 'object') {
      return raw.map(obj => ({
        id: obj.TaskId || obj.taskId || obj.taskid || '',
        title: obj.Title || obj.title || obj.TaskId || obj.taskId || obj.taskid || '',
        parentId: obj.ParentId || obj.parentId || obj.parentid || '',
        isFolder: toBool(obj.IsFolder || obj.isFolder || obj.isfolder),
        attribute: normalizeAttribute(obj.Attribute || obj.attribute)
      })).filter(t => t.id);
    }
    return [];
  }
  function buildTaskPathMap(tasks) {
    const map = new Map();
    tasks.forEach(t => map.set(String(t.id), t));
    const cache = {};
    const visiting = new Set();
    const resolve = (id) => {
      const key = String(id);
      if (cache[key]) return cache[key];
      if (visiting.has(key)) return map.get(key)?.title || key;
      visiting.add(key);
      const t = map.get(key);
      if (!t) { visiting.delete(key); return key; }
      const self = t.title || key;
      const parentId = t.parentId && map.has(String(t.parentId)) ? String(t.parentId) : '';
      const parentPath = parentId ? resolve(parentId) : '';
      const path = parentPath ? `${parentPath} / ${self}` : self;
      cache[key] = path;
      visiting.delete(key);
      return path;
    };
    tasks.forEach(t => { if (!t.isFolder) resolve(t.id); });
    return { cache, map };
  }
  function classifyTasks(tasks, states) {
    const grouped = { cleared: [], graded: [], submitted: [], pending: [] };
    const stateMap = states || {};
    const { cache: pathMap, map } = buildTaskPathMap(tasks);
    tasks.forEach(t => {
      if (t.isFolder) return;
      if (normalizeAttribute(t.attribute) === 'その他') return;
      const state = stateMap[t.id] || {};
      const submitted = toBool(state.submitted);
      const scoreRaw = state.score;
      const scorePresent = scoreRaw !== undefined && scoreRaw !== null && String(scoreRaw).trim() !== '';
      const scoreNum = Number(scoreRaw);
      const hasNumeric = scorePresent && !Number.isNaN(scoreNum);
      let bucket = 'pending';
      if (submitted) bucket = 'submitted';
      else if (hasNumeric && scoreNum === 100) bucket = 'cleared';
      else if (hasNumeric && scoreNum < 100) bucket = 'graded';
      const path = pathMap[t.id] || t.title || t.id;
      grouped[bucket].push({ id: t.id, path, parentId: t.parentId });
    });
    Object.keys(grouped).forEach(k => {
      grouped[k].sort((a, b) => (a.path || '').localeCompare(b.path || '', 'ja'));
    });
    return grouped;
  }
  function startFromTask(taskId) {
    try { localStorage.setItem(SELECTED_KEY(), String(taskId || '')); } catch (e) { console.warn('[index] failed to store selected task', e); }
    try {
      const taskMap = new Map();
      lastSnapshotTasks.forEach(t => taskMap.set(String(t.id), t));
      const chain = [];
      let cur = taskMap.get(String(taskId));
      const safeGuard = new Set();
      while (cur && cur.parentId) {
        const pid = String(cur.parentId);
        if (safeGuard.has(pid)) break;
        safeGuard.add(pid);
        chain.push(pid);
        cur = taskMap.get(pid);
      }
      let collapsed = {};
      try { collapsed = JSON.parse(localStorage.getItem(BASE_KEY('collapsed')) || '{}') || {}; } catch (_) { collapsed = {}; }
      chain.forEach(pid => { collapsed[pid] = false; });
      localStorage.setItem(BASE_KEY('collapsed'), JSON.stringify(collapsed));
    } catch (err) {
      console.warn('[index] failed to expand parents', err);
    }
    location.href = 'main.html';
  }
  function renderSnapshotSummary(snapshot) {
    const container = document.getElementById('taskStateSummary');
    if (!container) return;
    if (!snapshot || !Array.isArray(snapshot.tasks) || snapshot.tasks.length === 0) {
      container.hidden = true;
      return;
    }
    const tasks = normalizeSnapshotTasks(snapshot.tasks);
    if (tasks.length === 0) {
      container.hidden = true;
      return;
    }
    lastSnapshotTasks = tasks;
    const grouped = classifyTasks(tasks, snapshot.states || {});
    container.innerHTML = '';

    const caption = document.createElement('div');
    caption.className = 'state-caption';
    caption.textContent = '課題の状態';
    container.appendChild(caption);

    STATE_GROUPS.forEach(group => {
      const wrap = document.createElement('div');
      wrap.className = 'state-group';

      const header = document.createElement('div');
      header.className = 'state-header';

      const icon = document.createElement('span');
      const items = grouped[group.key] || [];
      const isCleared = group.key === 'cleared';
      icon.className = `state-icon task-icon ${isCleared ? 'sparkle-star' : 'dot-icon'}`;
      icon.textContent = isCleared ? '★' : '●';
      if (!isCleared) icon.style.color = STATE_COLORS[group.key] || STATE_COLORS.pending;

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'state-toggle';
      toggle.textContent = '▶';
      toggle.setAttribute('aria-expanded', 'false');

      const title = document.createElement('span');
      title.className = 'state-title';
      title.textContent = group.label;

      const count = document.createElement('span');
      count.className = 'state-count';
      count.textContent = `(${items.length}件)`;

      const list = document.createElement('ul');
      list.className = 'state-list';
      list.hidden = true;

      if (items.length === 0) {
        const empty = document.createElement('li');
        empty.className = 'state-empty';
        empty.textContent = '該当なし';
        list.appendChild(empty);
      } else {
        items.forEach(item => {
          const li = document.createElement('li');
          li.className = 'state-item';
          const titleSpan = document.createElement('span');
          titleSpan.className = 'state-title-text';
          titleSpan.textContent = item.path || item.id;
          const startBtn = document.createElement('button');
          startBtn.type = 'button';
          startBtn.className = 'state-start-btn';
          startBtn.textContent = 'この課題からはじめる';
          startBtn.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            startFromTask(item.id);
          });
          li.appendChild(titleSpan);
          li.appendChild(startBtn);
          list.appendChild(li);
        });
      }

      const setExpanded = (open) => {
        list.hidden = !open;
        toggle.textContent = open ? '▼' : '▶';
        toggle.setAttribute('aria-expanded', String(open));
      };
      toggle.addEventListener('click', (ev) => {
        ev.preventDefault();
        setExpanded(list.hidden);
      });
      header.addEventListener('click', (ev) => {
        if (ev.target === toggle) return;
        setExpanded(list.hidden);
      });

      header.appendChild(icon);
      header.appendChild(toggle);
      header.appendChild(title);
      header.appendChild(count);
      wrap.appendChild(header);
      wrap.appendChild(list);
      container.appendChild(wrap);
    });

    container.hidden = false;
  }
  function renderSnapshotSummaryFromStorage() {
    const container = document.getElementById('taskStateSummary');
    if (!container) return;
    const hasSession = !!(localStorage.getItem('sessionId') || sessionStorage.getItem('sessionId'));
    if (!hasSession) { container.hidden = true; return; }
    try {
      const key = window.__SNAP_KEY__;
      if (!key) { container.hidden = true; return; }
      const raw = localStorage.getItem(key);
      if (!raw) { container.hidden = true; return; }
      const snap = JSON.parse(raw);
      renderSnapshotSummary(snap);
    } catch (err) {
      console.warn('[index] renderSnapshotSummaryFromStorage error', err);
      container.hidden = true;
    }
  }

  async function startPreload(){
    if (__preloadRunning) { console.log('[index] preload: already running, skip'); return; }
    __preloadRunning = true;
    try{
      const sessionId = localStorage.getItem('sessionId');
      if (!sessionId) { console.log('[index] preload: no sessionId, skip'); return; } // 未ログインは従来どおり
      console.log('[index] preload: start, serverBaseUrl=', serverBaseUrl, 'key=', window.__SNAP_KEY__);

      // 「main.html へ」ボタンを探して一時的に隠す（見つかれば）
      const startLink = document.querySelector('a[href="main.html"], #startProgrammingButton, .start-program-btn, #primaryBtn');
      if (startLink) {
        startLink.classList.add('start-program-btn');
        startLink.style.display = 'none';
        const s = document.createElement('div');
        s.id = 'preloadStatus';
        s.textContent = '課題データを準備中…';
        startLink.parentNode.insertBefore(s, startLink);
      }

      // フォームエンコードでPOST（CORSプリフライト回避）
      const toForm = (obj) => Object.keys(obj).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(obj[k] ?? '')).join('&');
      const res = await fetch(buildUrl(), {
        method: 'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: toForm({ action: 'getUserSnapshot', session: sessionId })
      });
      const json = await res.json();
      if (json && json.status === 'ok') {
        const key = `learn.snapshot.${serverBaseUrl}`;
        const payload = { tasks: json.tasks, states: json.states || {}, fetchedAt: Date.now() };
        localStorage.setItem(key, JSON.stringify(payload));
        console.log('[index] preload: snapshot saved', { key, tasks: Array.isArray(json.tasks)? json.tasks.length : -1,
                                                        stateKeys: json.states? Object.keys(json.states).length : 0 });
        renderSnapshotSummary(payload);
      } else {
        console.warn('[index] preload: snapshot failed', json);
        renderSnapshotSummaryFromStorage();
      }
    } catch(e){
      console.error('[index] preload error', e);
      renderSnapshotSummaryFromStorage();
    } finally{
      const startLink = document.querySelector('a[href="main.html"], #startProgrammingButton, .start-program-btn, #primaryBtn');
      const st = document.getElementById('preloadStatus');
      if (st) st.remove();
      if (startLink) startLink.style.display = ''; // 表示OK
      console.log('[index] preload: done');
      __preloadRunning = false;
      renderSnapshotSummaryFromStorage();
    }
  }

  // DOM構築後、すでに sessionId があれば即プリロード
  document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('sessionId')) {
      console.log('[index] DOMContentLoaded: session present, preload now');
      renderSnapshotSummaryFromStorage();
      startPreload();
    } else {
      renderSnapshotSummaryFromStorage();
    }
  });
  // セッションがvalidate後に確定した場合はこちらでプリロード開始
  window.addEventListener('session-ready', startPreload);
})();
</script>
</html>
