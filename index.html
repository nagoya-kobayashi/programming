<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>トップ | プログラミング学習</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <script src="config.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    .container { max-width: 720px; margin: 40px auto; padding: 24px; border: 1px solid #e5e5e5; border-radius: 12px; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .meta { color: #555; margin-bottom: 16px; }
    .actions { margin-top: 20px; display: flex; gap: 12px; }
    button { padding: 10px 16px; border-radius: 8px; border: 1px solid #ccc; background: #1677ff; color: #fff; cursor: pointer; }
    button.secondary { background: #fff; color: #1677ff; border-color: #1677ff; }
    .msg { margin-top: 12px; color: #888; }
    .task-state-summary { margin-top: 16px; padding: 12px; border: 1px solid #e5e5e5; border-radius: 10px; background: #fafafa; }
    .task-state-summary .state-group { margin-top: 8px; }
    .task-state-summary .state-header { display: flex; align-items: center; gap: 8px; cursor: pointer; }
    .task-state-summary .state-toggle { width: 26px; height: 26px; padding: 0; border-radius: 6px; border: 1px solid #ccc; background: #fff; color: #555; font-size: 14px; line-height: 1; }
    .task-state-summary .state-toggle:focus { outline: 2px solid #91caff; outline-offset: 1px; }
    .task-state-summary .state-header .state-icon { margin-right: 4px; }
    .task-state-summary .state-list .state-item { display: flex; align-items: center; gap: 8px; justify-content: space-between; }
    .task-state-summary .state-list .state-item .state-title-text { flex: 1 1 auto; }
    .task-state-summary .state-list .state-start-btn { padding: 4px 8px; font-size: 0.9em; border-radius: 6px; border: 1px solid #1677ff; background: #f0f7ff; color: #1677ff; cursor: pointer; }
    .task-state-summary .state-list .state-start-btn:hover { background: #e6f0ff; }
    .task-state-summary .state-title { font-weight: 600; }
    .task-state-summary .state-count { color: #666; font-size: 0.9em; }
    .task-state-summary .state-list { margin: 6px 0 0 34px; padding: 0; }
    .task-state-summary .state-list li { list-style: none; padding: 2px 0; color: #333; font-size: 0.95em; word-break: break-all; }
    .task-state-summary .state-empty { color: #777; font-size: 0.9em; margin-left: 0; }
    .task-state-summary .state-caption { font-weight: 700; color: #444; margin-bottom: 4px; }
    .attr-progress { margin-top: 6px; padding: 6px 4px 4px; border-top: 1px dashed #e0e0e0; display: flex; flex-direction: column; gap: 6px; }
    .attr-progress-caption { font-weight: 700; color: #333; }
    .attr-progress-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .attr-progress-label { min-width: 110px; font-weight: 600; color: #444; }
    .attr-progress-stars { display: flex; gap: 3px; flex-wrap: wrap; align-items: center; }
    .attr-star { font-size: 1.05rem; line-height: 1.2; }
    .attr-star.filled.basic { color: #52c41a; }
    .attr-star.filled.exercise { color: #1890ff; }
    .attr-star.filled.advanced { color: #ff4d4f; }
    .attr-star.empty { color: #d9d9d9; }
    .attr-progress-none { color: #999; font-size: 0.9rem; }
  </style>
  <style>
    /* トップページのハイスコア表示 */
    .top-scores { margin-top: 16px; padding: 12px; border: 1px solid #e5e5e5; border-radius: 10px; background: #f7fbff; }
    .top-scores__head { display: flex; justify-content: flex-start; align-items: baseline; gap: 8px; flex-wrap: wrap; }
    .top-scores__title { font-weight: 700; color: #1d1d1f; }
    .top-scores__table-wrap { margin-top: 8px; overflow: auto; }
    .top-scores__table { border-collapse: separate; border-spacing: 0; min-width: 520px; width: 100%; }
    .top-scores__table thead th { background: #eef4ff; color: #1d1d1f; font-size: 12px; padding: 4px 5px; border: 1px solid #dbe6ff; text-align: center; white-space: nowrap; }
    .top-scores__table tbody td { background: #fff; border: 1px solid #e5e5e5; padding: 3px 4px; font-size: 12px; text-align: center; }
    .top-scores__table .rank-col { position: sticky; left: 0; width: 28px; background: #f7fbff; font-weight: 800; color: #1677ff; }
    .top-scores__table .cls-col { position: sticky; left: 28px; background: #f7fbff; font-weight: 700; min-width: 70px; }
    .top-scores__table .clear-col { min-width: 70px; }
    .top-scores__table .sum-col { min-width: 90px; }
    .top-scores__table .attr-col { min-width: 120px; text-align: left; white-space: nowrap; }
    .top-scores__table .compact-token { margin-right: 3px; font-weight: 700; }
    .top-scores__table th.task-head { min-width: 30px; }
    .top-scores__table .score-cell { font-variant-numeric: tabular-nums; }
    .top-scores__table .score-star { color: #f5a524; font-weight: 800; }
    .top-scores__status { margin-top: 8px; color: #888; font-size: 0.9em; }
    .user-mini { margin: 10px 0 8px; padding: 8px 10px; border: 1px solid #e0e0e0; border-radius: 8px; background: #f5f9ff; font-weight: 600; color: #2b2b2b; font-size: 14px; }
    .user-mini .muted { color: #666; font-weight: 500; }
  </style>
  <style>
    /* 事前プリロード中の簡易インジケータ */
    #preloadStatus { font-size: 0.9em; color: #555; margin: 8px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>プログラミング学習</h1>
    <div id="meta" class="meta"></div>
    <div class="actions">
      <button id="primaryBtn">読み込み中...</button>
    </div>
    <div id="note" class="msg"></div>
    <div id="taskStateSummary" class="task-state-summary" hidden></div>
    <div id="topScores" class="top-scores" hidden>
      <div class="top-scores__head">
        <div class="top-scores__title">ハイスコア（上位20名）</div>
      </div>
      <div class="top-scores__table-wrap">
        <table id="topScoresTable" class="top-scores__table"></table>
      </div>
      <div id="topScoresStatus" class="top-scores__status"></div>
    </div>
  </div>

  <script>
    (function(){
      const meta = document.getElementById('meta');
      const btn = document.getElementById('primaryBtn');
      const note = document.getElementById('note');

      const APP = window.APP_CONFIG || {};
      const server = APP.serverBaseUrl || '';

      function qs(key){ return new URLSearchParams(location.search).get(key); }
      function setSession(sid, uid, cls, num){
        try {
          localStorage.setItem('sessionId', sid);
          localStorage.setItem('userId', uid || '');
          localStorage.setItem('classId', cls || '');
          localStorage.setItem('number', num || '');
          sessionStorage.setItem('sessionId', sid);
          sessionStorage.setItem('userId', uid || '');
          sessionStorage.setItem('classId', cls || '');
          sessionStorage.setItem('number', num || '');
        } catch {}
      }

      const toForm = (obj) => Object.keys(obj).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(obj[k] ?? '')).join('&');

      async function validateSession(sid){
        if (!server || !sid) return null;
        try{
          // 既存デプロイに確実に存在する ping を使用（session付きでvalidate）
          const res = await fetch(server, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: toForm({ action: 'ping', session: sid })
          });
          if (!res.ok) { console.warn('[index] validateSession http', res.status); return null; }
          const data = await res.json();
          if (data && data.status === 'ok'){
            // ユーザ情報が帰ってくる場合のみ上書き（無くてもOK）
            if (data.userId || data.classId || data.number) {
              setSession(sid, data.userId, data.classId, data.number);
            }
            return data;
          }
          console.warn('[index] validateSession app err', data);
          // ここで null 返すとUIがセッション破棄動線に落ちるため、nullでは返さない
          return {status:'ok'}; // 最低限OK扱いにしてプリロードを継続
        }catch(e){
          console.warn('[index] validateSession err', e);
          return {status:'ok'}; // ネットワーク断でもセッションを維持
        }
      }

      async function main(){
        btn.disabled = true; btn.textContent = '読み込み中...';
        // 1) sid= がURLにある場合は優先採用
        const sidFromUrl = qs('sid');
        if (sidFromUrl){
          const v = await validateSession(sidFromUrl);
          if (v){
            meta.textContent = `クラス:${v.classId || '?'}　出席番号:${v.number || '?'}（${v.userId || ''}）`;
            btn.textContent = 'プログラミングをはじめる';
            btn.disabled = false;
            btn.onclick = () => location.href = 'main.html';
            note.textContent = 'QRコード等からのアクセスを検出しました。上のボタンから学習画面へ進んでください。';
            // ← セッション確定を通知（プリロードはこのイベントで開始）
            window.dispatchEvent(new Event('session-ready'));
            return;
          } else {
            note.textContent = 'URLのセッションが無効でした。ログインしてください。';
            // fallthrough to local check
          }
        }

        // 2) localStorage の sessionId
        const sidLocal = localStorage.getItem('sessionId');
        if (sidLocal){
          const v = await validateSession(sidLocal);
          // pingは status:ok になればOK扱い。ユーザ詳細は無い場合もある。
          if (v && v.status === 'ok'){
            const uid = v.userId || localStorage.getItem('userId') || '';
            const cls = v.classId || localStorage.getItem('classId') || '?';
            const num = v.number || localStorage.getItem('number') || '?';
            meta.textContent = `クラス:${cls}　出席番号:${num}（${uid}）`;
            btn.textContent = 'プログラミングをはじめる';
            btn.disabled = false;
            btn.onclick = () => location.href = 'main.html';
            note.textContent = 'セッションを検出しました。上のボタンから学習画面へ進んでください。';
            // ← セッション確定を通知（プリロードはこのイベントで開始）
            window.dispatchEvent(new Event('session-ready'));
            return;
          }
          // ここでは sessionId を破棄しない（プリロードとUI継続のため）
        }

        // 3) セッション無し → ログイン導線のみ
        meta.textContent = 'セッションが見つかりませんでした。';
        btn.textContent = 'ログインしてプログラミングをはじめる';
        btn.disabled = false;
        btn.onclick = () => location.href = 'login.html';
        note.textContent = '学校内PCでは初回は登録ページから、2回目以降はログインなしで学習画面に遷移できます。';
      }

      main();
    })();
  </script>
</body>
<script>
// 事前プリロード：セッションがあれば課題一覧＋ユーザー状態をまとめて取得し、localStorageへ保存
(function(){
  const serverBaseUrl = (window.APP_CONFIG && window.APP_CONFIG.serverBaseUrl) || '';
  const buildUrl = (path = '') => {
    if (serverBaseUrl.includes('script.google.com')) return serverBaseUrl;
    return serverBaseUrl + path;
  };
  // デバッグ用にキーを参照できるよう公開
  window.__SNAP_KEY__ = `learn.snapshot.${serverBaseUrl}`;
  // 多重起動ガード
  let __preloadRunning = false;
  const STATE_GROUPS = [
    { key: 'cleared', label: 'クリア済' },
    { key: 'graded', label: '採点済' },
    { key: 'submitted', label: '提出済' },
    { key: 'pending', label: '未提出' }
  ];
  const STATE_COLORS = {
    cleared: '#52c41a',
    graded: '#ff8fb7',
    submitted: '#9254de',
    pending: '#d9d9d9'
  };
  const ATTR_PROGRESS_META = [
    { key: '基礎', className: 'basic' },
    { key: '演習', className: 'exercise' },
    { key: '発展', className: 'advanced' }
  ];
  const BASE_KEY = (suffix) => {
    const base = (typeof (window.APP_CONFIG || {}).serverBaseUrl === 'string' && (window.APP_CONFIG || {}).serverBaseUrl) || 'default';
    return `learn.${suffix}.${base}`;
  };
  const SELECTED_KEY = () => BASE_KEY('selectedTask');
  const TOP_SCORES_LIMIT = 20;
  const EXCLUDE_ATTRIBUTE = 'その他';
  const ATTR_ALLOWED = ['基礎', '演習', '発展', 'その他'];
  const ATTR_COLORS = {
    '基礎': '#35c759',
    '演習': '#2d8dfc',
    '発展': '#ff4d67',
    'その他': '#f3b12f'
  };

  async function fetchUserProgressCached() {
    if (!serverBaseUrl) return null;
    try {
      const params = new URLSearchParams();
      params.append('action', 'getUserProgress');
      const res = await fetch(buildUrl(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      if (!data || data.status !== 'ok') throw new Error(data && data.message ? data.message : 'load failed');
      return data;
    } catch (err) {
      console.warn('[index] fetchUserProgressCached failed', err);
      return null;
    }
  }

  function renderTopScores(data) {
    const wrap = document.getElementById('topScores');
    const tableEl = document.getElementById('topScoresTable');
    const statusEl = document.getElementById('topScoresStatus');
    if (!wrap || !tableEl || !statusEl) return;

    tableEl.innerHTML = '';
    statusEl.textContent = '';

    if (!data || !Array.isArray(data.tasks) || !Array.isArray(data.rows)) {
      wrap.hidden = true;
      return;
    }
    const tasks = data.tasks || [];
    const filteredTasks = tasks
      .map((t, idx) => ({ ...t, idx, attribute: normalizeAttribute(t.attribute) }))
      .filter(t => t.attribute !== EXCLUDE_ATTRIBUTE && t.isFolder !== true);
    if (!filteredTasks.length) {
      statusEl.textContent = '表示対象の課題がありません（その他を除外しています）';
      wrap.hidden = false;
      return;
    }

    const entries = data.rows.map(row => {
      let scoreSum = 0;
      let cleared = 0;
      const total = filteredTasks.length;
      const scores = filteredTasks.map(t => {
        const scoreRaw = row.scores ? row.scores[t.idx] : '';
        const num = Number(scoreRaw);
        if (!Number.isNaN(num)) {
          scoreSum += num;
          if (num === 100) cleared += 1;
        }
        return { taskId: t.taskId, value: scoreRaw, attribute: t.attribute };
      });
      return { classId: row.classId || '', scoreSum, cleared, total, scores };
    });

    const sorted = entries
      .filter(e => e.scoreSum || e.scoreSum === 0)
      .sort((a, b) => b.scoreSum - a.scoreSum)
      .slice(0, TOP_SCORES_LIMIT);

    if (!sorted.length) {
      statusEl.textContent = '表示できるスコアがありません';
      wrap.hidden = false;
      return;
    }

    // ヘッダ作成（属性 / フォルダ / 課題名）
    const thead = document.createElement('thead');
    const attrRow = document.createElement('tr');

    const headerCells = [
      { text: '順位', className: 'rank-col' },
      { text: 'クラス', className: 'cls-col' },
      { text: 'クリア件数', className: 'clear-col' },
      { text: 'スコア合計', className: 'sum-col' },
      { text: '基礎', className: 'attr-col', attr: '基礎' },
      { text: '演習', className: 'attr-col', attr: '演習' },
      { text: '発展', className: 'attr-col', attr: '発展' }
    ];
    headerCells.forEach((h) => {
      const th = document.createElement('th');
      th.textContent = h.text;
      th.className = h.className || '';
      th.rowSpan = 1;
      attrRow.appendChild(th);
    });

    thead.appendChild(attrRow);

    const tbody = document.createElement('tbody');
    sorted.forEach((e, i) => {
      const tr = document.createElement('tr');
      const rankTd = document.createElement('td');
      rankTd.className = 'rank-col';
      rankTd.textContent = i + 1;
      const clsTd = document.createElement('td');
      clsTd.className = 'cls-col';
      clsTd.textContent = e.classId || '―';
      const clearTd = document.createElement('td');
      clearTd.className = 'clear-col';
      clearTd.textContent = `${e.cleared}/${e.total}`;
      const sumTd = document.createElement('td');
      sumTd.className = 'sum-col';
      sumTd.textContent = e.scoreSum;
      tr.appendChild(rankTd);
      tr.appendChild(clsTd);
      tr.appendChild(clearTd);
      tr.appendChild(sumTd);

      ['基礎', '演習', '発展'].forEach(attr => {
        const td = document.createElement('td');
        td.className = 'attr-col';
        td.style.color = ATTR_COLORS[attr] || '#1f1f1f';
        const tokens = [];
        filteredTasks.forEach((t, idx) => {
          if (t.attribute !== attr) return;
          const score = e.scores[idx] ? e.scores[idx].value : '';
          const num = Number(score);
          if (score === '' || score === null || score === undefined) {
            tokens.push('');
          } else if (!Number.isNaN(num) && num === 100) {
            tokens.push('★');
          } else if (!Number.isNaN(num) && num !== 0) {
            tokens.push(String(num));
          } else {
            tokens.push('');
          }
        });
        td.textContent = tokens.join('');
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    tableEl.innerHTML = '';
    tableEl.appendChild(thead);
    tableEl.appendChild(tbody);

    statusEl.textContent = '';
    wrap.hidden = false;
  }

  function summarizeSelfProgress(tasks, states) {
    let total = 0;
    let cleared = 0;
    let scoreSum = 0;
    let maxScore = 0;
    const attrSet = new Set(ATTR_ALLOWED);
    tasks.forEach(t => {
      const attr = normalizeAttribute(t.attribute);
      if (!attrSet.has(attr) || attr === EXCLUDE_ATTRIBUTE) return;
      if (t.isFolder) return;
      total += 1;
      maxScore += 100;
      const st = states[String(t.id)] || states[t.id] || {};
      const raw = st.score;
      const num = Number(raw);
      if (!Number.isNaN(num)) {
        scoreSum += num;
        if (num === 100) cleared += 1;
      }
    });
    return { total, cleared, scoreSum, maxScore };
  }
  function canonicalHeader(h) { return String(h || '').replace(/^\uFEFF/, '').trim().toLowerCase(); }
  function toBool(v) { const s = String(v || '').trim().toLowerCase(); return s === 'true' || s === '1' || s === 'yes' || s === 'y'; }
  function normalizeAttribute(value) {
    const s = String(value || '').replace(/\s+/g, '').trim();
    const allowed = ['基礎', '演習', '発展', 'その他'];
    if (!s) return 'その他';
    return allowed.includes(s) ? s : 'その他';
  }
  function normalizeSnapshotTasks(raw) {
    if (!Array.isArray(raw) || raw.length === 0) return [];
    if (Array.isArray(raw[0])) {
      const headerRow = raw[0].map(h => canonicalHeader(h));
      const rows = raw.slice(1);
      const idx = {
        taskid: headerRow.indexOf('taskid'),
        title: headerRow.indexOf('title'),
        parentid: headerRow.indexOf('parentid'),
        isfolder: headerRow.indexOf('isfolder'),
        attribute: headerRow.indexOf('attribute')
      };
      const pick = (row, i) => (i >= 0 && i != null) ? row[i] : '';
      return rows.map(r => ({
        id: pick(r, idx.taskid) || '',
        title: pick(r, idx.title) || pick(r, idx.taskid) || '',
        parentId: pick(r, idx.parentid) || '',
        isFolder: toBool(pick(r, idx.isfolder)),
        attribute: normalizeAttribute(pick(r, idx.attribute))
      })).filter(t => t.id);
    }
    if (typeof raw[0] === 'object') {
      return raw.map(obj => ({
        id: obj.TaskId || obj.taskId || obj.taskid || '',
        title: obj.Title || obj.title || obj.TaskId || obj.taskId || obj.taskid || '',
        parentId: obj.ParentId || obj.parentId || obj.parentid || '',
        isFolder: toBool(obj.IsFolder || obj.isFolder || obj.isfolder),
        attribute: normalizeAttribute(obj.Attribute || obj.attribute)
      })).filter(t => t.id);
    }
    return [];
  }
  function buildTaskPathMap(tasks) {
    const map = new Map();
    tasks.forEach(t => map.set(String(t.id), t));
    const cache = {};
    const visiting = new Set();
    const resolve = (id) => {
      const key = String(id);
      if (cache[key]) return cache[key];
      if (visiting.has(key)) return map.get(key)?.title || key;
      visiting.add(key);
      const t = map.get(key);
      if (!t) { visiting.delete(key); return key; }
      const self = t.title || key;
      const parentId = t.parentId && map.has(String(t.parentId)) ? String(t.parentId) : '';
      const parentPath = parentId ? resolve(parentId) : '';
      const path = parentPath ? `${parentPath} / ${self}` : self;
      cache[key] = path;
      visiting.delete(key);
      return path;
    };
    tasks.forEach(t => { if (!t.isFolder) resolve(t.id); });
    return { cache, map };
  }
  function classifyTasks(tasks, states) {
    const grouped = { cleared: [], graded: [], submitted: [], pending: [] };
    const stateMap = states || {};
    const { cache: pathMap, map } = buildTaskPathMap(tasks);
    tasks.forEach(t => {
      if (t.isFolder) return;
      if (normalizeAttribute(t.attribute) === 'その他') return;
      const state = stateMap[t.id] || {};
      const submitted = toBool(state.submitted);
      const scoreRaw = state.score;
      const scorePresent = scoreRaw !== undefined && scoreRaw !== null && String(scoreRaw).trim() !== '';
      const scoreNum = Number(scoreRaw);
      const hasNumeric = scorePresent && !Number.isNaN(scoreNum);
      let bucket = 'pending';
      if (submitted) bucket = 'submitted';
      else if (hasNumeric && scoreNum === 100) bucket = 'cleared';
      else if (hasNumeric && scoreNum < 100) bucket = 'graded';
      const path = pathMap[t.id] || t.title || t.id;
      grouped[bucket].push({ id: t.id, path, parentId: t.parentId });
    });
    Object.keys(grouped).forEach(k => {
      grouped[k].sort((a, b) => (a.path || '').localeCompare(b.path || '', 'ja'));
    });
    return grouped;
  }
  function isClearedState(state) {
    if (!state) return false;
    const scoreRaw = state.score;
    if (scoreRaw === undefined || scoreRaw === null || String(scoreRaw).trim() === '') return false;
    const numeric = Number(scoreRaw);
    return !Number.isNaN(numeric) && numeric === 100;
  }
  function calcAttributeProgress(tasks, states) {
    const buckets = Object.create(null);
    ATTR_PROGRESS_META.forEach(meta => { buckets[meta.key] = { total: 0, cleared: 0, className: meta.className }; });
    const stateMap = states || {};
    tasks.forEach(t => {
      const attr = normalizeAttribute(t.attribute);
      if (!attr || attr === 'その他' || t.isFolder) return;
      if (!buckets[attr]) return;
      buckets[attr].total += 1;
      const state = stateMap[t.id] || stateMap[String(t.id)];
      if (isClearedState(state)) buckets[attr].cleared += 1;
    });
    return ATTR_PROGRESS_META.map(meta => ({ label: meta.key, className: meta.className, ...buckets[meta.key] }));
  }
  function renderAttributeProgress(container, tasks, states) {
    const progress = calcAttributeProgress(tasks, states);
    if (!progress.some(p => p.total > 0)) return;
    const wrap = document.createElement('div');
    wrap.className = 'attr-progress';
    const caption = document.createElement('div');
    caption.className = 'attr-progress-caption';
    caption.textContent = '属性別クリア率';
    wrap.appendChild(caption);
    progress.forEach(p => {
      const row = document.createElement('div');
      row.className = 'attr-progress-row';
      const label = document.createElement('span');
      label.className = 'attr-progress-label';
      label.textContent = `${p.label} (${p.cleared}/${p.total})`;
      const stars = document.createElement('div');
      stars.className = 'attr-progress-stars';
      if (p.total === 0) {
        const none = document.createElement('span');
        none.className = 'attr-progress-none';
        none.textContent = '課題なし';
        stars.appendChild(none);
      } else {
        const makeStar = (filled) => {
          const el = document.createElement('span');
          el.className = `attr-star ${filled ? 'filled' : 'empty'}${filled ? ' ' + p.className : ''}`;
          el.textContent = filled ? '★' : '☆';
          return el;
        };
        for (let i = 0; i < p.cleared; i++) stars.appendChild(makeStar(true));
        for (let i = p.cleared; i < p.total; i++) stars.appendChild(makeStar(false));
      }
      row.appendChild(label);
      row.appendChild(stars);
      wrap.appendChild(row);
    });
    container.appendChild(wrap);
  }
  function startFromTask(taskId) {
    try { localStorage.setItem(SELECTED_KEY(), String(taskId || '')); } catch (e) { console.warn('[index] failed to store selected task', e); }
    try {
      const taskMap = new Map();
      lastSnapshotTasks.forEach(t => taskMap.set(String(t.id), t));
      const chain = [];
      let cur = taskMap.get(String(taskId));
      const safeGuard = new Set();
      while (cur && cur.parentId) {
        const pid = String(cur.parentId);
        if (safeGuard.has(pid)) break;
        safeGuard.add(pid);
        chain.push(pid);
        cur = taskMap.get(pid);
      }
      let collapsed = {};
      try { collapsed = JSON.parse(localStorage.getItem(BASE_KEY('collapsed')) || '{}') || {}; } catch (_) { collapsed = {}; }
      chain.forEach(pid => { collapsed[pid] = false; });
      localStorage.setItem(BASE_KEY('collapsed'), JSON.stringify(collapsed));
    } catch (err) {
      console.warn('[index] failed to expand parents', err);
    }
    location.href = 'main.html';
  }
  function renderSnapshotSummary(snapshot) {
    const container = document.getElementById('taskStateSummary');
    if (!container) return;
    if (!snapshot || !Array.isArray(snapshot.tasks) || snapshot.tasks.length === 0) {
      container.hidden = true;
      return;
    }
    const tasks = normalizeSnapshotTasks(snapshot.tasks);
    if (tasks.length === 0) {
      container.hidden = true;
      return;
    }
    lastSnapshotTasks = tasks;
    const grouped = classifyTasks(tasks, snapshot.states || {});
    container.innerHTML = '';

    const selfMini = summarizeSelfProgress(tasks, snapshot.states || {});
    if (selfMini.total > 0) {
      const mini = document.createElement('div');
      mini.className = 'user-mini';
      mini.textContent = `あなたの進捗: クリア件数 ${selfMini.cleared}/${selfMini.total}｜スコア ${selfMini.scoreSum}/${selfMini.maxScore}`;
      container.appendChild(mini);
    }

    const caption = document.createElement('div');
    caption.className = 'state-caption';
    caption.textContent = '課題の状態';
    container.appendChild(caption);

    renderAttributeProgress(container, tasks, snapshot.states || {});

    STATE_GROUPS.forEach(group => {
      const wrap = document.createElement('div');
      wrap.className = 'state-group';

      const header = document.createElement('div');
      header.className = 'state-header';

      const icon = document.createElement('span');
      const items = grouped[group.key] || [];
      const isCleared = group.key === 'cleared';
      icon.className = `state-icon task-icon ${isCleared ? 'sparkle-star' : 'dot-icon'}`;
      icon.textContent = isCleared ? '★' : '●';
      if (!isCleared) icon.style.color = STATE_COLORS[group.key] || STATE_COLORS.pending;

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'state-toggle';
      toggle.textContent = '▶';
      toggle.setAttribute('aria-expanded', 'false');

      const title = document.createElement('span');
      title.className = 'state-title';
      title.textContent = group.label;

      const count = document.createElement('span');
      count.className = 'state-count';
      count.textContent = `(${items.length}件)`;

      const list = document.createElement('ul');
      list.className = 'state-list';
      list.hidden = true;

      if (items.length === 0) {
        const empty = document.createElement('li');
        empty.className = 'state-empty';
        empty.textContent = '該当なし';
        list.appendChild(empty);
      } else {
        items.forEach(item => {
          const li = document.createElement('li');
          li.className = 'state-item';
          const titleSpan = document.createElement('span');
          titleSpan.className = 'state-title-text';
          titleSpan.textContent = item.path || item.id;
          const startBtn = document.createElement('button');
          startBtn.type = 'button';
          startBtn.className = 'state-start-btn';
          startBtn.textContent = 'この課題からはじめる';
          startBtn.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            startFromTask(item.id);
          });
          li.appendChild(titleSpan);
          li.appendChild(startBtn);
          list.appendChild(li);
        });
      }

      const setExpanded = (open) => {
        list.hidden = !open;
        toggle.textContent = open ? '▼' : '▶';
        toggle.setAttribute('aria-expanded', String(open));
      };
      toggle.addEventListener('click', (ev) => {
        ev.preventDefault();
        setExpanded(list.hidden);
      });
      header.addEventListener('click', (ev) => {
        if (ev.target === toggle) return;
        setExpanded(list.hidden);
      });

      header.appendChild(icon);
      header.appendChild(toggle);
      header.appendChild(title);
      header.appendChild(count);
      wrap.appendChild(header);
      wrap.appendChild(list);
      container.appendChild(wrap);
    });

    container.hidden = false;
  }
  function renderSnapshotSummaryFromStorage() {
    const container = document.getElementById('taskStateSummary');
    if (!container) return;
    const hasSession = !!(localStorage.getItem('sessionId') || sessionStorage.getItem('sessionId'));
    if (!hasSession) { container.hidden = true; return; }
    try {
      const key = window.__SNAP_KEY__;
      if (!key) { container.hidden = true; return; }
      const raw = localStorage.getItem(key);
      if (!raw) { container.hidden = true; return; }
      const snap = JSON.parse(raw);
      renderSnapshotSummary(snap);
    } catch (err) {
      console.warn('[index] renderSnapshotSummaryFromStorage error', err);
      container.hidden = true;
    }
  }

  async function startPreload(){
    if (__preloadRunning) { console.log('[index] preload: already running, skip'); return; }
    __preloadRunning = true;
    try{
      const sessionId = localStorage.getItem('sessionId');
      if (!sessionId) { console.log('[index] preload: no sessionId, skip'); return; } // 未ログインは従来どおり
      console.log('[index] preload: start, serverBaseUrl=', serverBaseUrl, 'key=', window.__SNAP_KEY__);

      // 「main.html へ」ボタンを探して一時的に隠す（見つかれば）
      const startLink = document.querySelector('a[href="main.html"], #startProgrammingButton, .start-program-btn, #primaryBtn');
      if (startLink) {
        startLink.classList.add('start-program-btn');
        startLink.style.display = 'none';
        const s = document.createElement('div');
        s.id = 'preloadStatus';
        s.textContent = '課題データを準備中…';
        startLink.parentNode.insertBefore(s, startLink);
      }

      // フォームエンコードでPOST（CORSプリフライト回避）
      const toForm = (obj) => Object.keys(obj).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(obj[k] ?? '')).join('&');
      const res = await fetch(buildUrl(), {
        method: 'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: toForm({ action: 'getUserSnapshot', session: sessionId })
      });
      const json = await res.json();
      if (json && json.status === 'ok') {
        const key = `learn.snapshot.${serverBaseUrl}`;
        const payload = { tasks: json.tasks, states: json.states || {}, fetchedAt: Date.now() };
        localStorage.setItem(key, JSON.stringify(payload));
        console.log('[index] preload: snapshot saved', { key, tasks: Array.isArray(json.tasks)? json.tasks.length : -1,
                                                        stateKeys: json.states? Object.keys(json.states).length : 0 });
        renderSnapshotSummary(payload);
      } else {
        console.warn('[index] preload: snapshot failed', json);
        renderSnapshotSummaryFromStorage();
      }
    } catch(e){
      console.error('[index] preload error', e);
      renderSnapshotSummaryFromStorage();
    } finally{
      const startLink = document.querySelector('a[href="main.html"], #startProgrammingButton, .start-program-btn, #primaryBtn');
      const st = document.getElementById('preloadStatus');
      if (st) st.remove();
      if (startLink) startLink.style.display = ''; // 表示OK
      console.log('[index] preload: done');
      __preloadRunning = false;
      renderSnapshotSummaryFromStorage();
      // ハイスコアも読み込み（シート読み込みのみ）
      const prog = await fetchUserProgressCached();
      renderTopScores(prog);
    }
  }

  // DOM構築後、すでに sessionId があれば即プリロード
  document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('sessionId')) {
      console.log('[index] DOMContentLoaded: session present, preload now');
      renderSnapshotSummaryFromStorage();
      startPreload();
    } else {
      renderSnapshotSummaryFromStorage();
      // セッションが無くてもシートは閲覧だけ行う（必要に応じて表示）
      fetchUserProgressCached().then(renderTopScores);
    }
  });
  // セッションがvalidate後に確定した場合はこちらでプリロード開始
  window.addEventListener('session-ready', startPreload);
})();
</script>
</html>
